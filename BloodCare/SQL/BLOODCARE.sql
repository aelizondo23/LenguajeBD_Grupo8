CREATE TABLE tipo_sangre (
    id_tipo_sangre    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tipo              VARCHAR2(5) UNIQUE NOT NULL
);

-- Tabla 2: Donante
CREATE TABLE donante (
    id_donante        VARCHAR2(20) PRIMARY KEY,
    nombre            VARCHAR2(50),
    apellido          VARCHAR2(50),
    direccion         VARCHAR2(100),
    fecha_nacimiento  DATE,
    sexo              VARCHAR2(1),
    telefono          VARCHAR2(20),
    correo            VARCHAR2(100),
    id_tipo_sangre    NUMBER,
    CONSTRAINT fk_donante_tipo_sangre FOREIGN KEY (id_tipo_sangre)
        REFERENCES tipo_sangre(id_tipo_sangre)
);

-- Tabla 3: Centro Donacion
CREATE TABLE centro_donacion (
    id_centro         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre            VARCHAR2(100),
    ubicacion         VARCHAR2(150),
    tipo              VARCHAR2(50)
);

-- Tabla 4: Rol
CREATE TABLE rol (
    id_rol            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre_rol        VARCHAR2(50),
    descripcion       VARCHAR2(255)
);

-- Tabla 8: Componente Sangu neo
CREATE TABLE componente_sanguineo (
    id_componente     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre            VARCHAR2(50),
    descripcion       VARCHAR2(255)
);

-- Tabla 5: Usuario
CREATE TABLE usuario (
    id_usuario        VARCHAR2(20) PRIMARY KEY,
    nombre_usuario    VARCHAR2(50) UNIQUE,
    correo            VARCHAR2(100),
    contrasena        VARCHAR2(100),
    estado            VARCHAR2(10),
    id_rol            NUMBER,
    CONSTRAINT fk_usuario_rol FOREIGN KEY (id_rol)
        REFERENCES rol(id_rol)
);

-- Tabla 6: Donaci n
CREATE TABLE donacion (
    id_donacion       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_donante        VARCHAR2(20),
    id_centro         NUMBER,
    fecha             DATE,
    volumen_ml        NUMBER,
    estado            VARCHAR2(20),
    id_usuario_registra VARCHAR2(20),
    CONSTRAINT fk_donacion_donante FOREIGN KEY (id_donante)
        REFERENCES donante(id_donante),
    CONSTRAINT fk_donacion_centro FOREIGN KEY (id_centro)
        REFERENCES centro_donacion(id_centro),
    CONSTRAINT fk_donacion_usuario FOREIGN KEY (id_usuario_registra)
        REFERENCES usuario(id_usuario)
);

-- Tabla 7: Donaci n Componente
CREATE TABLE donacion_componente (
    id_donacion_componente NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_donacion            NUMBER,
    id_componente          NUMBER,
    unidades               NUMBER,
    CONSTRAINT fk_don_comp_donacion FOREIGN KEY (id_donacion)
        REFERENCES donacion(id_donacion),
    CONSTRAINT fk_don_comp_componente FOREIGN KEY (id_componente)
        REFERENCES componente_sanguineo(id_componente)
);

-- Tabla 9: Inventario
CREATE TABLE inventario (
    id_inventario         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_componente         NUMBER,
    id_tipo_sangre        NUMBER,
    unidades_disponibles  NUMBER,
    fecha_actualiza       DATE,
    id_usuario_actualiza  VARCHAR2(20),
    CONSTRAINT fk_inv_componente FOREIGN KEY (id_componente)
        REFERENCES componente_sanguineo(id_componente),
    CONSTRAINT fk_inv_tipo_sangre FOREIGN KEY (id_tipo_sangre)
        REFERENCES tipo_sangre(id_tipo_sangre),
    CONSTRAINT fk_inv_usuario FOREIGN KEY (id_usuario_actualiza)
        REFERENCES usuario(id_usuario)
);

-- Tabla 10: Causa Rechazo
CREATE TABLE causa_rechazo (
    id_causa          NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    descripcion       VARCHAR2(255)
);

-- Tabla 11: Rechazo
CREATE TABLE rechazo (
    id_rechazo        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_donacion       NUMBER,
    id_causa          NUMBER,
    observaciones     VARCHAR2(255),
    usuario_registra  VARCHAR2(20),
    CONSTRAINT fk_rechazo_donacion FOREIGN KEY (id_donacion)
        REFERENCES donacion(id_donacion),
    CONSTRAINT fk_rechazo_causa FOREIGN KEY (id_causa)
        REFERENCES causa_rechazo(id_causa),
    CONSTRAINT fk_rechazo_usuario FOREIGN KEY (usuario_registra)
        REFERENCES usuario(id_usuario)
);

-- Tabla 12: Bit cora
CREATE TABLE bitacora (
    id_bitacora       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_usuario        VARCHAR2(20),
    accion            VARCHAR2(50),
    fecha_hora        TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    detalle           VARCHAR2(500),
    CONSTRAINT fk_bitacora_usuario FOREIGN KEY (id_usuario)
        REFERENCES usuario(id_usuario)
);

CREATE SEQUENCE bitacora_seq START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE donacion_comp_seq START WITH 1 INCREMENT BY 1;

---- Insercion.sql:------------

INSERT INTO rol (nombre_rol, descripcion) VALUES ('Administrador', 'Acceso completo al sistema');
INSERT INTO rol (nombre_rol, descripcion) VALUES ('Diplomado', 'Gestiona donantes, registros de donaciones y visualiza inventario');
INSERT INTO rol (nombre_rol, descripcion) VALUES ('Tecnico', 'Control del inventario y rechazo de donaciones');
INSERT INTO rol (nombre_rol, descripcion) VALUES ('Microbiologo', 'Acceso a registros, inventarios y causas de rechazo');
INSERT INTO rol (nombre_rol, descripcion) VALUES ('Jefatura', 'Acceso al sistema, pero no puede crear usuarios');

--Usuarios--
-- Usuario Administrador
INSERT INTO usuario (id_usuario, nombre_usuario, correo, contrasena, estado, id_rol)
VALUES ('USR001', 'admin1', 'admin1@bloodcare.com', 'admin123', 'Activo', 1);

-- Usuario Diplomado
INSERT INTO usuario (id_usuario, nombre_usuario, correo, contrasena, estado, id_rol)
VALUES ('USR002', 'diplomado1', 'diplomado1@bloodcare.com', 'diplomado123', 'Activo', 2);

-- Usuario T cnico
INSERT INTO usuario (id_usuario, nombre_usuario, correo, contrasena, estado, id_rol)
VALUES ('USR003', 'tecnico1', 'tecnico1@bloodcare.com', 'tecnico123', 'Activo', 3);

-- Usuario Microbiologo
INSERT INTO usuario (id_usuario, nombre_usuario, correo, contrasena, estado, id_rol)
VALUES ('USR004', 'micro1', 'micro1@bloodcare.com', 'micro123', 'Activo', 4);

-- Usuario Jefatura
INSERT INTO usuario (id_usuario, nombre_usuario, correo, contrasena, estado, id_rol)
VALUES ('USR005', 'jefatura1', 'jefatura1@bloodcare.com', 'jefatura123', 'Activo', 5);

INSERT INTO tipo_sangre (tipo) VALUES ('A+');
INSERT INTO tipo_sangre (tipo) VALUES ('A-');
INSERT INTO tipo_sangre (tipo) VALUES ('B+');
INSERT INTO tipo_sangre (tipo) VALUES ('B-');
INSERT INTO tipo_sangre (tipo) VALUES ('O+');
INSERT INTO tipo_sangre (tipo) VALUES ('O-');
INSERT INTO tipo_sangre (tipo) VALUES ('AB+');
INSERT INTO tipo_sangre (tipo) VALUES ('AB-');

COMMIT;

--insercion de donantes
INSERT INTO donante (id_donante, nombre, apellido, direccion, fecha_nacimiento, sexo, telefono, correo, id_tipo_sangre)
VALUES ('101010101', 'Andrea', 'Mora Salazar', 'San Jos , Rohrmoser', TO_DATE('1991-04-15','YYYY-MM-DD'), 'F', '8888-1010', 'andrea.mora@example.com', 1);

INSERT INTO donante (id_donante, nombre, apellido, direccion, fecha_nacimiento, sexo, telefono, correo, id_tipo_sangre)
VALUES ('202020202', 'Luis', 'Cordero Jim nez', 'Cartago, El Guarco', TO_DATE('1989-06-22','YYYY-MM-DD'), 'M', '8899-2020', 'luis.cordero@example.com', 2);

INSERT INTO donante (id_donante, nombre, apellido, direccion, fecha_nacimiento, sexo, telefono, correo, id_tipo_sangre)
VALUES ('303030303', 'Mar a Jos ', 'Sol s Vargas', 'Alajuela, San Rafael', TO_DATE('1993-12-09','YYYY-MM-DD'), 'F', '8700-3030', 'mariaj.solis@example.com', 3);

INSERT INTO donante (id_donante, nombre, apellido, direccion, fecha_nacimiento, sexo, telefono, correo, id_tipo_sangre)
VALUES ('404040404', 'Jorge', 'Rodr guez  lvarez', 'Heredia, Barva', TO_DATE('1990-01-30','YYYY-MM-DD'), 'M', '8711-4040', 'jorge.r@example.com', 4);

INSERT INTO donante (id_donante, nombre, apellido, direccion, fecha_nacimiento, sexo, telefono, correo, id_tipo_sangre)
VALUES ('505050505', 'Paola', 'Z  iga Chac n', 'San Jos , Curridabat', TO_DATE('1987-10-18','YYYY-MM-DD'), 'F', '8722-5050', 'paola.z@example.com', 5);

INSERT INTO donante (id_donante, nombre, apellido, direccion, fecha_nacimiento, sexo, telefono, correo, id_tipo_sangre)
VALUES ('606060606', 'Carlos', 'Alp zar Mar n', 'Puntarenas, Parrita', TO_DATE('1995-07-11','YYYY-MM-DD'), 'M', '8733-6060', 'carlos.alpizar@example.com', 6);

INSERT INTO donante (id_donante, nombre, apellido, direccion, fecha_nacimiento, sexo, telefono, correo, id_tipo_sangre)
VALUES ('707070707', 'Estefany', 'Guzm n Valverde', 'Guanacaste, Santa Cruz', TO_DATE('1992-03-26','YYYY-MM-DD'), 'F', '8744-7070', 'estefany.g@example.com', 7);

INSERT INTO donante (id_donante, nombre, apellido, direccion, fecha_nacimiento, sexo, telefono, correo, id_tipo_sangre)
VALUES ('808080808', 'Jos  Miguel', 'S nchez Rivera', 'Lim n, Siquirres', TO_DATE('1988-09-14','YYYY-MM-DD'), 'M', '8755-8080', 'jose.sanchez@example.com', 8);

INSERT INTO donante (id_donante, nombre, apellido, direccion, fecha_nacimiento, sexo, telefono, correo, id_tipo_sangre)
VALUES ('909090909', 'Karina', 'Campos Rojas', 'San Jos , Desamparados', TO_DATE('1994-11-03','YYYY-MM-DD'), 'F', '8766-9090', 'karina.campos@example.com', 2);

INSERT INTO donante (id_donante, nombre, apellido, direccion, fecha_nacimiento, sexo, telefono, correo, id_tipo_sangre)
VALUES ('111111111', 'Ricardo', 'Castillo Fallas', 'Alajuela, Grecia', TO_DATE('1996-05-20','YYYY-MM-DD'), 'M', '8777-1111', 'ricardo.castillo@example.com', 1);

---insercion de centros

-- Insertar centros de donaci n
INSERT INTO centro_donacion (nombre, ubicacion, tipo)
VALUES ('Hospital San Vicente de Paul', 'Heredia centro', 'Fijo');

INSERT INTO centro_donacion (nombre, ubicacion, tipo)
VALUES ('Empresa Cerveceria de Costa Rica', 'Heredia Centro, Heredia', 'M vil');

INSERT INTO centro_donacion (nombre, ubicacion, tipo)
VALUES ('Campa a Universitaria', 'UCR Sede Rodrigo Facio', 'Campa a');


-- componente_sanguineo
INSERT INTO componente_sanguineo (nombre, descripcion) 
VALUES ('Gl bulos Rojos', 'Transportan oxigeno desde los pulmones al resto del cuerpo y dioxido de carbono de vuelta a los pulmones.');

INSERT INTO componente_sanguineo (nombre, descripcion) 
VALUES ('Plaquetas', 'Ayudan a la coagulacion de la sangre deteniendo hemorragias en heridas o lesiones.');

INSERT INTO componente_sanguineo (nombre, descripcion) 
VALUES ('Plasma', 'Contiene proteinas y factores de coagulacion, transporta nutrientes, hormonas y desechos.');


SELECT * FROM donacion;


-- 1. Registrar donante
CREATE OR REPLACE PROCEDURE registrar_donante (
  p_id_donante       IN VARCHAR2,
  p_nombre           IN VARCHAR2,
  p_apellido         IN VARCHAR2,
  p_direccion        IN VARCHAR2,
  p_fecha_nacimiento IN DATE,
  p_sexo             IN VARCHAR2,
  p_telefono         IN VARCHAR2,
  p_correo           IN VARCHAR2,
  p_id_tipo_sangre   IN NUMBER
) IS
BEGIN
  INSERT INTO donante(id_donante, nombre, apellido, direccion, fecha_nacimiento, sexo, telefono, correo, id_tipo_sangre)
  VALUES (p_id_donante, p_nombre, p_apellido, p_direccion, p_fecha_nacimiento, p_sexo, p_telefono, p_correo, p_id_tipo_sangre);
  COMMIT;
END;
/

-- 2. Actualizar donante
CREATE OR REPLACE PROCEDURE actualizar_donante (
  p_id_donante       IN VARCHAR2,
  p_nombre           IN VARCHAR2,
  p_apellido         IN VARCHAR2,
  p_direccion        IN VARCHAR2,
  p_fecha_nacimiento IN DATE,
  p_sexo             IN VARCHAR2,
  p_telefono         IN VARCHAR2,
  p_correo           IN VARCHAR2,
  p_id_tipo_sangre   IN NUMBER
) IS
BEGIN
  UPDATE donante SET
    nombre = p_nombre,
    apellido = p_apellido,
    direccion = p_direccion,
    fecha_nacimiento = p_fecha_nacimiento,
    sexo = p_sexo,
    telefono = p_telefono,
    correo = p_correo,
    id_tipo_sangre = p_id_tipo_sangre
  WHERE id_donante = p_id_donante;
  COMMIT;
END;
/

-- 3. Eliminar donante (solo si no tiene donaciones)
CREATE OR REPLACE PROCEDURE eliminar_donante (
  p_id_donante IN VARCHAR2
) IS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM donacion WHERE id_donante = p_id_donante;
  IF v_count = 0 THEN
    DELETE FROM donante WHERE id_donante = p_id_donante;
    COMMIT;
  ELSE
    RAISE_APPLICATION_ERROR(-20001, 'No se puede eliminar donante con donaciones registradas.');
  END IF;
END;
/

-- 4. Registrar donaci n
CREATE OR REPLACE PROCEDURE registrar_donacion (
  p_id_donante       IN VARCHAR2,
  p_id_centro        IN NUMBER,
  p_fecha            IN DATE,
  p_volumen_ml       IN NUMBER,
  p_estado           IN VARCHAR2,
  p_id_usuario       IN VARCHAR2
) IS
BEGIN
  INSERT INTO donacion(id_donante, id_centro, fecha, volumen_ml, estado, id_usuario_registra)
  VALUES (p_id_donante, p_id_centro, p_fecha, p_volumen_ml, p_estado, p_id_usuario);
  COMMIT;
END;
/

-- 5. Actualizar donaci n
CREATE OR REPLACE PROCEDURE actualizar_donacion (
  p_id_donacion      IN NUMBER,
  p_fecha            IN DATE,
  p_volumen_ml       IN NUMBER,
  p_estado           IN VARCHAR2,
  p_id_centro        IN NUMBER
) IS
BEGIN
  UPDATE donacion SET
    fecha = p_fecha,
    volumen_ml = p_volumen_ml,
    estado = p_estado,
    id_centro = p_id_centro
  WHERE id_donacion = p_id_donacion;
  COMMIT;
END;
/

-- 6. Registrar rechazo
CREATE OR REPLACE PROCEDURE registrar_rechazo (
  p_id_donacion      IN NUMBER,
  p_id_causa         IN NUMBER,
  p_observaciones    IN VARCHAR2,
  p_usuario_registra IN VARCHAR2
) IS
BEGIN
  INSERT INTO rechazo(id_donacion, id_causa, observaciones, usuario_registra)
  VALUES (p_id_donacion, p_id_causa, p_observaciones, p_usuario_registra);
  COMMIT;
END;
/

-- 7. Actualizar rechazo
CREATE OR REPLACE PROCEDURE actualizar_rechazo (
  p_id_rechazo       IN NUMBER,
  p_id_causa         IN NUMBER,
  p_observaciones    IN VARCHAR2
) IS
BEGIN
  UPDATE rechazo SET
    id_causa = p_id_causa,
    observaciones = p_observaciones
  WHERE id_rechazo = p_id_rechazo;
  COMMIT;
END;
/

-- 8. Registrar nuevo componente sangu neo
CREATE OR REPLACE PROCEDURE registrar_componente (
  p_nombre      IN VARCHAR2,
  p_descripcion IN VARCHAR2
) IS
BEGIN
  INSERT INTO componente_sanguineo(nombre, descripcion)
  VALUES (p_nombre, p_descripcion);
  COMMIT;
END;
/

-- 9. Actualizar componente sangu neo
CREATE OR REPLACE PROCEDURE actualizar_componente (
  p_id_componente IN NUMBER,
  p_nombre       IN VARCHAR2,
  p_descripcion  IN VARCHAR2
) IS
BEGIN
  UPDATE componente_sanguineo SET
    nombre = p_nombre,
    descripcion = p_descripcion
  WHERE id_componente = p_id_componente;
  COMMIT;
END;
/

-- 10. Actualizar inventario
CREATE OR REPLACE PROCEDURE actualizar_inventario (
  p_id_componente    IN NUMBER,
  p_id_tipo_sangre   IN NUMBER,
  p_unidades         IN NUMBER,
  p_id_usuario       IN VARCHAR2
) IS
  v_existente NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_existente
  FROM inventario
  WHERE id_componente = p_id_componente AND id_tipo_sangre = p_id_tipo_sangre;

  IF v_existente > 0 THEN
    UPDATE inventario
    SET unidades_disponibles = unidades_disponibles + p_unidades,
        fecha_actualiza = SYSDATE,
        id_usuario_actualiza = p_id_usuario
    WHERE id_componente = p_id_componente AND id_tipo_sangre = p_id_tipo_sangre;
  ELSE
    INSERT INTO inventario(id_componente, id_tipo_sangre, unidades_disponibles, fecha_actualiza, id_usuario_actualiza)
    VALUES (p_id_componente, p_id_tipo_sangre, p_unidades, SYSDATE, p_id_usuario);
  END IF;
  COMMIT;
END;
/

-- 11. Consultar inventario por tipo sangre y componente (procedimiento simple)
CREATE OR REPLACE PROCEDURE consultar_inventario (
  p_id_tipo_sangre IN NUMBER,
  p_id_componente  IN NUMBER,
  p_unidades      OUT NUMBER
) IS
BEGIN
  SELECT unidades_disponibles INTO p_unidades
  FROM inventario
  WHERE id_tipo_sangre = p_id_tipo_sangre AND id_componente = p_id_componente;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    p_unidades := 0;
END;
/

-- 12. Registrar centro de donaci n
CREATE OR REPLACE PROCEDURE registrar_centro_donacion (
  p_nombre   IN VARCHAR2,
  p_ubicacion IN VARCHAR2,
  p_tipo     IN VARCHAR2
) IS
BEGIN
  INSERT INTO centro_donacion(nombre, ubicacion, tipo)
  VALUES (p_nombre, p_ubicacion, p_tipo);
  COMMIT;
END;
/

-- 13. Actualizar centro de donaci n
CREATE OR REPLACE PROCEDURE actualizar_centro_donacion (
  p_id_centro IN NUMBER,
  p_nombre    IN VARCHAR2,
  p_ubicacion IN VARCHAR2,
  p_tipo      IN VARCHAR2
) IS
BEGIN
  UPDATE centro_donacion SET
    nombre = p_nombre,
    ubicacion = p_ubicacion,
    tipo = p_tipo
  WHERE id_centro = p_id_centro;
  COMMIT;
END;
/

-- 14. Registrar usuario
CREATE OR REPLACE PROCEDURE registrar_usuario (
  p_id_usuario    IN VARCHAR2,
  p_nombre_usuario IN VARCHAR2,
  p_correo        IN VARCHAR2,
  p_contrasena    IN VARCHAR2,
  p_estado        IN VARCHAR2,
  p_id_rol        IN NUMBER
) IS
BEGIN
  INSERT INTO usuario(id_usuario, nombre_usuario, correo, contrasena, estado, id_rol)
  VALUES (p_id_usuario, p_nombre_usuario, p_correo, p_contrasena, p_estado, p_id_rol);
  COMMIT;
END;
/

-- 15. Actualizar usuario
CREATE OR REPLACE PROCEDURE actualizar_usuario (
  p_id_usuario    IN VARCHAR2,
  p_nombre_usuario IN VARCHAR2,
  p_correo        IN VARCHAR2,
  p_contrasena    IN VARCHAR2,
  p_estado        IN VARCHAR2,
  p_id_rol        IN NUMBER
) IS
BEGIN
  UPDATE usuario SET
    nombre_usuario = p_nombre_usuario,
    correo = p_correo,
    contrasena = p_contrasena,
    estado = p_estado,
    id_rol = p_id_rol
  WHERE id_usuario = p_id_usuario;
  COMMIT;
END;
/

-- 16. Cambiar estado de usuario (activo/inactivo)
CREATE OR REPLACE PROCEDURE cambiar_estado_usuario (
  p_id_usuario IN VARCHAR2,
  p_estado     IN VARCHAR2
) IS
BEGIN
  UPDATE usuario SET estado = p_estado WHERE id_usuario = p_id_usuario;
  COMMIT;
END;
/

-- 17. Registrar causa de rechazo
CREATE OR REPLACE PROCEDURE registrar_causa_rechazo (
  p_descripcion IN VARCHAR2
) IS
BEGIN
  INSERT INTO causa_rechazo(descripcion) VALUES (p_descripcion);
  COMMIT;
END;
/

-- 18. Actualizar causa de rechazo
CREATE OR REPLACE PROCEDURE actualizar_causa_rechazo (
  p_id_causa   IN NUMBER,
  p_descripcion IN VARCHAR2
) IS
BEGIN
  UPDATE causa_rechazo SET descripcion = p_descripcion WHERE id_causa = p_id_causa;
  COMMIT;
END;
/

-- 19. Registrar rol
CREATE OR REPLACE PROCEDURE registrar_rol (
  p_nombre_rol IN VARCHAR2,
  p_descripcion IN VARCHAR2
) IS
BEGIN
  INSERT INTO rol(nombre_rol, descripcion) VALUES (p_nombre_rol, p_descripcion);
  COMMIT;
END;
/

-- 20. Actualizar rol
CREATE OR REPLACE PROCEDURE actualizar_rol (
  p_id_rol IN NUMBER,
  p_nombre_rol IN VARCHAR2,
  p_descripcion IN VARCHAR2
) IS
BEGIN
  UPDATE rol SET nombre_rol = p_nombre_rol, descripcion = p_descripcion WHERE id_rol = p_id_rol;
  COMMIT;
END;
/

-- 21. Registrar donaci n componente
CREATE OR REPLACE PROCEDURE registrar_donacion_componente (
  p_id_donacion  IN NUMBER,
  p_id_componente IN NUMBER,
  p_unidades     IN NUMBER
) IS
BEGIN
  INSERT INTO donacion_componente(id_donacion, id_componente, unidades)
  VALUES (p_id_donacion, p_id_componente, p_unidades);
  COMMIT;
END;
/

-- 22. Actualizar donacion componente
CREATE OR REPLACE PROCEDURE actualizar_donacion_componente (
  p_id_donacion_componente IN NUMBER,
  p_unidades               IN NUMBER
) IS
BEGIN
  UPDATE donacion_componente SET unidades = p_unidades
  WHERE id_donacion_componente = p_id_donacion_componente;
  COMMIT;
END;
/

-- 23. Eliminar donacion componente
CREATE OR REPLACE PROCEDURE eliminar_donacion_componente (
  p_id_donacion_componente IN NUMBER
) IS
BEGIN
  DELETE FROM donacion_componente WHERE id_donacion_componente = p_id_donacion_componente;
  COMMIT;
END;
/

-- 24. Registrar bitacora
CREATE OR REPLACE PROCEDURE registrar_bitacora (
  p_id_usuario IN VARCHAR2,
  p_accion     IN VARCHAR2,
  p_detalle    IN VARCHAR2
) IS
BEGIN
  INSERT INTO bitacora(id_usuario, accion, detalle)
  VALUES (p_id_usuario, p_accion, p_detalle);
  COMMIT;
END;
/

-- 25. Consultar cantidad donaciones por donante (procedimiento con cursor para reporte)
CREATE OR REPLACE PROCEDURE contar_donaciones_por_donante (
  p_id_donante IN VARCHAR2,
  p_total     OUT NUMBER
) IS
BEGIN
  SELECT COUNT(*) INTO p_total FROM donacion WHERE id_donante = p_id_donante;
END;
/


-- Funciones

-- 1. Funci n que obtiene nombre completo de donante
CREATE OR REPLACE FUNCTION obtener_nombre_completo(
  p_id_donante IN VARCHAR2
) RETURN VARCHAR2 IS
  v_nombre VARCHAR2(100);
BEGIN
  SELECT nombre || ' ' || apellido INTO v_nombre FROM donante WHERE id_donante = p_id_donante;
  RETURN v_nombre;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END;
/

-- 2. Funci n para verificar si donante existe
CREATE OR REPLACE FUNCTION existe_donante(
  p_id_donante IN VARCHAR2
) RETURN BOOLEAN IS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM donante WHERE id_donante = p_id_donante;
  RETURN (v_count > 0);
END;
/

-- 3. Funci n que calcula edad del donante
CREATE OR REPLACE FUNCTION calcular_edad(
  p_id_donante IN VARCHAR2
) RETURN NUMBER IS
  v_fecha_nac DATE;
  v_edad NUMBER;
BEGIN
  SELECT fecha_nacimiento INTO v_fecha_nac FROM donante WHERE id_donante = p_id_donante;
  v_edad := FLOOR(MONTHS_BETWEEN(SYSDATE, v_fecha_nac) / 12);
  RETURN v_edad;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END;
/

-- 4. Funci n que devuelve unidades disponibles de un inventario
CREATE OR REPLACE FUNCTION obtener_unidades_inventario(
  p_id_componente  IN NUMBER,
  p_id_tipo_sangre IN NUMBER
) RETURN NUMBER IS
  v_unidades NUMBER;
BEGIN
  SELECT unidades_disponibles INTO v_unidades
  FROM inventario
  WHERE id_componente = p_id_componente AND id_tipo_sangre = p_id_tipo_sangre;
  RETURN v_unidades;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN 0;
END;
/

-- 5. Funci n para validar correo de usuario (simple)
CREATE OR REPLACE FUNCTION validar_correo_usuario(
  p_correo IN VARCHAR2
) RETURN BOOLEAN IS
BEGIN
  RETURN (REGEXP_LIKE(p_correo, '^[^@]+@[^@]+\.[^@]+$'));
END;
/

-- 6. Funci n que obtiene nombre de componente sangu neo
CREATE OR REPLACE FUNCTION obtener_nombre_componente(
  p_id_componente IN NUMBER
) RETURN VARCHAR2 IS
  v_nombre VARCHAR2(100);
BEGIN
  SELECT nombre INTO v_nombre FROM componente_sanguineo WHERE id_componente = p_id_componente;
  RETURN v_nombre;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END;
/

-- 7. Funci n que obtiene descripci n de causa rechazo
CREATE OR REPLACE FUNCTION obtener_descripcion_causa(
  p_id_causa IN NUMBER
) RETURN VARCHAR2 IS
  v_desc VARCHAR2(200);
BEGIN
  SELECT descripcion INTO v_desc FROM causa_rechazo WHERE id_causa = p_id_causa;
  RETURN v_desc;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END;
/

-- 8. Funci n que obtiene nombre de rol
CREATE OR REPLACE FUNCTION obtener_nombre_rol(
  p_id_rol IN NUMBER
) RETURN VARCHAR2 IS
  v_nombre VARCHAR2(100);
BEGIN
  SELECT nombre_rol INTO v_nombre FROM rol WHERE id_rol = p_id_rol;
  RETURN v_nombre;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END;
/

-- 9. Funci n que verifica si usuario es activo
CREATE OR REPLACE FUNCTION es_usuario_activo(
  p_id_usuario IN VARCHAR2
) RETURN BOOLEAN IS
  v_estado VARCHAR2(10);
BEGIN
  SELECT estado INTO v_estado FROM usuario WHERE id_usuario = p_id_usuario;
  RETURN (v_estado = 'Activo');
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN FALSE;
END;
/

-- 10. Funci n que devuelve total de donaciones en un centro
CREATE OR REPLACE FUNCTION total_donaciones_centro(
  p_id_centro IN NUMBER
) RETURN NUMBER IS
  v_total NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_total FROM donacion WHERE id_centro = p_id_centro;
  RETURN v_total;
END;
/

-- 11. Funci n que devuelve si una donaci n tiene rechazo
CREATE OR REPLACE FUNCTION tiene_rechazo(
  p_id_donacion IN NUMBER
) RETURN BOOLEAN IS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM rechazo WHERE id_donacion = p_id_donacion;
  RETURN (v_count > 0);
END;
/

-- 12. Funci n que obtiene total unidades donacion componente
CREATE OR REPLACE FUNCTION total_unidades_donacion_componente(
  p_id_donacion IN NUMBER,
  p_id_componente IN NUMBER
) RETURN NUMBER IS
  v_unidades NUMBER;
BEGIN
  SELECT NVL(SUM(unidades),0) INTO v_unidades
  FROM donacion_componente
  WHERE id_donacion = p_id_donacion AND id_componente = p_id_componente;
  RETURN v_unidades;
END;
/

-- 13. Funci n para obtener fecha  ltima donaci n de donante
CREATE OR REPLACE FUNCTION fecha_ultima_donacion(
  p_id_donante IN VARCHAR2
) RETURN DATE IS
  v_fecha DATE;
BEGIN
  SELECT MAX(fecha) INTO v_fecha FROM donacion WHERE id_donante = p_id_donante;
  RETURN v_fecha;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END;
/

-- 14. Funci n para validar existencia de centro de donacion por nombre
CREATE OR REPLACE FUNCTION existe_centro(
  p_nombre IN VARCHAR2
) RETURN BOOLEAN IS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM centro_donacion WHERE nombre = p_nombre;
  RETURN (v_count > 0);
END;
/

-- 15. Funci n para validar existencia de usuario por correo
CREATE OR REPLACE FUNCTION existe_usuario_por_correo(
  p_correo IN VARCHAR2
) RETURN BOOLEAN IS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM usuario WHERE correo = p_correo;
  RETURN (v_count > 0);
END;
/


-- Paquetes

CREATE OR REPLACE PACKAGE PAQ_DONANTE AS
  PROCEDURE REGISTRAR_DONANTE(
    p_id_donante       IN donante.id_donante%TYPE,
    p_nombre           IN donante.nombre%TYPE,
    p_apellido         IN donante.apellido%TYPE,
    p_direccion        IN donante.direccion%TYPE,
    p_fecha_nacimiento IN donante.fecha_nacimiento%TYPE,
    p_sexo             IN donante.sexo%TYPE,
    p_telefono         IN donante.telefono%TYPE,
    p_correo           IN donante.correo%TYPE,
    p_id_tipo_sangre   IN donante.id_tipo_sangre%TYPE
  );

  PROCEDURE ACTUALIZAR_DONANTE(
    p_id_donante       IN donante.id_donante%TYPE,
    p_nombre           IN donante.nombre%TYPE,
    p_apellido         IN donante.apellido%TYPE,
    p_direccion        IN donante.direccion%TYPE,
    p_fecha_nacimiento IN donante.fecha_nacimiento%TYPE,
    p_sexo             IN donante.sexo%TYPE,
    p_telefono         IN donante.telefono%TYPE,
    p_correo           IN donante.correo%TYPE,
    p_id_tipo_sangre   IN donante.id_tipo_sangre%TYPE
  );

  PROCEDURE ELIMINAR_DONANTE(p_id_donante IN donante.id_donante%TYPE);

  PROCEDURE OBTENER_DONANTE(
    p_id_donante IN donante.id_donante%TYPE,
    p_out        OUT SYS_REFCURSOR
  );

  PROCEDURE LISTAR_DONANTES(p_out OUT SYS_REFCURSOR);

  FUNCTION FN_DONANTE_EXISTE(p_id_donante IN donante.id_donante%TYPE) RETURN NUMBER;
END PAQ_DONANTE;
/
CREATE OR REPLACE PACKAGE BODY PAQ_DONANTE AS

  PROCEDURE REGISTRAR_DONANTE(
    p_id_donante       IN donante.id_donante%TYPE,
    p_nombre           IN donante.nombre%TYPE,
    p_apellido         IN donante.apellido%TYPE,
    p_direccion        IN donante.direccion%TYPE,
    p_fecha_nacimiento IN donante.fecha_nacimiento%TYPE,
    p_sexo             IN donante.sexo%TYPE,
    p_telefono         IN donante.telefono%TYPE,
    p_correo           IN donante.correo%TYPE,
    p_id_tipo_sangre   IN donante.id_tipo_sangre%TYPE
  ) IS
  BEGIN
    -- si quieres delegar en tu paquete actual:
    -- PKG_DONANTE.INSERTAR_DONANTE(...);

    -- implementaci n directa equivalente:
    INSERT INTO donante(
      id_donante, nombre, apellido, direccion, fecha_nacimiento,
      sexo, telefono, correo, id_tipo_sangre
    )
    VALUES(
      p_id_donante, p_nombre, p_apellido, p_direccion, p_fecha_nacimiento,
      p_sexo, p_telefono, p_correo, p_id_tipo_sangre
    );
  END REGISTRAR_DONANTE;


  PROCEDURE ACTUALIZAR_DONANTE(
    p_id_donante       IN donante.id_donante%TYPE,
    p_nombre           IN donante.nombre%TYPE,
    p_apellido         IN donante.apellido%TYPE,
    p_direccion        IN donante.direccion%TYPE,
    p_fecha_nacimiento IN donante.fecha_nacimiento%TYPE,
    p_sexo             IN donante.sexo%TYPE,
    p_telefono         IN donante.telefono%TYPE,
    p_correo           IN donante.correo%TYPE,
    p_id_tipo_sangre   IN donante.id_tipo_sangre%TYPE
  ) IS
  BEGIN
    -- tu paquete solo ten a actualizar_contacto; aqu  hacemos UPDATE completo:
    UPDATE donante
       SET nombre           = p_nombre,
           apellido         = p_apellido,
           direccion        = p_direccion,
           fecha_nacimiento = p_fecha_nacimiento,
           sexo             = p_sexo,
           telefono         = p_telefono,
           correo           = p_correo,
           id_tipo_sangre   = p_id_tipo_sangre
     WHERE id_donante       = p_id_donante;
  END ACTUALIZAR_DONANTE;


  PROCEDURE ELIMINAR_DONANTE(p_id_donante IN donante.id_donante%TYPE) IS
  BEGIN
    -- o PKG_DONANTE.ELIMINAR_DONANTE(p_id_donante);
    DELETE FROM donante WHERE id_donante = p_id_donante;
  END ELIMINAR_DONANTE;


  PROCEDURE OBTENER_DONANTE(
    p_id_donante IN donante.id_donante%TYPE,
    p_out        OUT SYS_REFCURSOR
  ) IS
  BEGIN
    -- misma forma que en tu PKG_DONANTE
    OPEN p_out FOR
      SELECT d.*, ts.tipo AS tipo_sangre
        FROM donante d
        LEFT JOIN tipo_sangre ts ON ts.id_tipo_sangre = d.id_tipo_sangre
       WHERE d.id_donante = p_id_donante;
  END OBTENER_DONANTE;


  PROCEDURE LISTAR_DONANTES(p_out OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_out FOR
      SELECT d.*, ts.tipo AS tipo_sangre
        FROM donante d
        LEFT JOIN tipo_sangre ts ON ts.id_tipo_sangre = d.id_tipo_sangre
       ORDER BY d.apellido, d.nombre;
  END LISTAR_DONANTES;


  FUNCTION FN_DONANTE_EXISTE(p_id_donante IN donante.id_donante%TYPE) RETURN NUMBER IS
    v_cnt NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_cnt
      FROM donante
     WHERE id_donante = p_id_donante;

    RETURN CASE WHEN v_cnt > 0 THEN 1 ELSE 0 END;
  END FN_DONANTE_EXISTE;

END PAQ_DONANTE;
/



--2 Donacion

CREATE OR REPLACE PACKAGE pkg_donacion AS
  PROCEDURE registrar_donacion(
    p_id_donante         IN donacion.id_donante%TYPE,
    p_id_centro          IN donacion.id_centro%TYPE,
    p_fecha              IN donacion.fecha%TYPE,
    p_volumen_ml         IN donacion.volumen_ml%TYPE,
    p_estado             IN donacion.estado%TYPE,
    p_id_usuario_registra IN donacion.id_usuario_registra%TYPE,
    p_id_donacion_out    OUT donacion.id_donacion%TYPE
  );

  PROCEDURE agregar_componente(
    p_id_donacion  IN donacion_componente.id_donacion%TYPE,
    p_id_componente IN donacion_componente.id_componente%TYPE,
    p_unidades      IN donacion_componente.unidades%TYPE
  );

  PROCEDURE listar_donaciones(p_out OUT SYS_REFCURSOR);
  PROCEDURE obtener_por_id(p_id_donacion IN donacion.id_donacion%TYPE, p_out OUT SYS_REFCURSOR);
  FUNCTION  existe_donacion(p_id_donacion IN donacion.id_donacion%TYPE) RETURN NUMBER; -- 1/0
END pkg_donacion;
/
CREATE OR REPLACE PACKAGE BODY pkg_donacion AS
  PROCEDURE registrar_donacion(
    p_id_donante         IN donacion.id_donante%TYPE,
    p_id_centro          IN donacion.id_centro%TYPE,
    p_fecha              IN donacion.fecha%TYPE,
    p_volumen_ml         IN donacion.volumen_ml%TYPE,
    p_estado             IN donacion.estado%TYPE,
    p_id_usuario_registra IN donacion.id_usuario_registra%TYPE,
    p_id_donacion_out    OUT donacion.id_donacion%TYPE
  ) IS
  BEGIN
    INSERT INTO donacion(
      id_donante, id_centro, fecha, volumen_ml, estado, id_usuario_registra
    ) VALUES(
      p_id_donante, p_id_centro, p_fecha, p_volumen_ml, p_estado, p_id_usuario_registra
    )
    RETURNING id_donacion INTO p_id_donacion_out;
  END;

  PROCEDURE agregar_componente(
    p_id_donacion  IN donacion_componente.id_donacion%TYPE,
    p_id_componente IN donacion_componente.id_componente%TYPE,
    p_unidades      IN donacion_componente.unidades%TYPE
  ) IS
  BEGIN
    INSERT INTO donacion_componente(id_donacion, id_componente, unidades)
    VALUES(p_id_donacion, p_id_componente, p_unidades);
  END;

  PROCEDURE listar_donaciones(p_out OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_out FOR
      SELECT dn.*, cd.nombre AS centro, u.nombre_usuario AS usuario_registra
        FROM donacion dn
        LEFT JOIN centro_donacion cd ON cd.id_centro = dn.id_centro
        LEFT JOIN usuario u ON u.id_usuario = dn.id_usuario_registra
       ORDER BY dn.fecha DESC, dn.id_donacion DESC;
  END;

  PROCEDURE obtener_por_id(p_id_donacion IN donacion.id_donacion%TYPE, p_out OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_out FOR
      SELECT dn.*, cd.nombre AS centro, u.nombre_usuario AS usuario_registra
        FROM donacion dn
        LEFT JOIN centro_donacion cd ON cd.id_centro = dn.id_centro
        LEFT JOIN usuario u ON u.id_usuario = dn.id_usuario_registra
       WHERE dn.id_donacion = p_id_donacion;
  END;

  FUNCTION existe_donacion(p_id_donacion IN donacion.id_donacion%TYPE) RETURN NUMBER IS
    v_cnt NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_cnt FROM donacion WHERE id_donacion = p_id_donacion;
    RETURN CASE WHEN v_cnt > 0 THEN 1 ELSE 0 END;
  END;
END pkg_donacion;
/

--3 Recahzo

CREATE OR REPLACE PACKAGE pkg_rechazo AS
  PROCEDURE registrar_rechazo(
    p_id_donacion  IN rechazo.id_donacion%TYPE,
    p_id_causa     IN rechazo.id_causa%TYPE,
    p_observaciones IN rechazo.observaciones%TYPE,
    p_usuario_registra IN rechazo.usuario_registra%TYPE,
    p_id_rechazo_out OUT rechazo.id_rechazo%TYPE
  );
  PROCEDURE listar_por_donacion(p_id_donacion IN rechazo.id_donacion%TYPE, p_out OUT SYS_REFCURSOR);
  FUNCTION  descripcion_causa(p_id_rechazo IN rechazo.id_rechazo%TYPE) RETURN VARCHAR2;
END pkg_rechazo;
/
CREATE OR REPLACE PACKAGE BODY pkg_rechazo AS
  PROCEDURE registrar_rechazo(
    p_id_donacion  IN rechazo.id_donacion%TYPE,
    p_id_causa     IN rechazo.id_causa%TYPE,
    p_observaciones IN rechazo.observaciones%TYPE,
    p_usuario_registra IN rechazo.usuario_registra%TYPE,
    p_id_rechazo_out OUT rechazo.id_rechazo%TYPE
  ) IS
  BEGIN
    INSERT INTO rechazo(id_donacion, id_causa, observaciones, usuario_registra)
    VALUES(p_id_donacion, p_id_causa, p_observaciones, p_usuario_registra)
    RETURNING id_rechazo INTO p_id_rechazo_out;
  END;

  PROCEDURE listar_por_donacion(p_id_donacion IN rechazo.id_donacion%TYPE, p_out OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_out FOR
      SELECT r.*, c.descripcion AS causa
        FROM rechazo r
        JOIN causa_rechazo c ON c.id_causa = r.id_causa
       WHERE r.id_donacion = p_id_donacion
       ORDER BY r.id_rechazo DESC;
  END;

  FUNCTION descripcion_causa(p_id_rechazo IN rechazo.id_rechazo%TYPE) RETURN VARCHAR2 IS
    v_desc VARCHAR2(255);
  BEGIN
    SELECT c.descripcion
      INTO v_desc
      FROM rechazo r
      JOIN causa_rechazo c ON c.id_causa = r.id_causa
     WHERE r.id_rechazo = p_id_rechazo;
    RETURN v_desc;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RETURN NULL;
  END;
END pkg_rechazo;
/

--4 Inventario

CREATE OR REPLACE PACKAGE pkg_inventario AS
  PROCEDURE ajustar_stock(
    p_id_componente IN inventario.id_componente%TYPE,
    p_id_tipo_sangre IN inventario.id_tipo_sangre%TYPE,
    p_delta          IN NUMBER,
    p_id_usuario     IN inventario.id_usuario_actualiza%TYPE
  );
  FUNCTION consultar_stock(
    p_id_componente IN inventario.id_componente%TYPE,
    p_id_tipo_sangre IN inventario.id_tipo_sangre%TYPE
  ) RETURN NUMBER;
  FUNCTION hay_stock(
    p_id_componente IN inventario.id_componente%TYPE,
    p_id_tipo_sangre IN inventario.id_tipo_sangre%TYPE,
    p_necesario      IN NUMBER
  ) RETURN NUMBER; -- 1/0
END pkg_inventario;
/
CREATE OR REPLACE PACKAGE BODY pkg_inventario AS
  PROCEDURE ajustar_stock(
    p_id_componente IN inventario.id_componente%TYPE,
    p_id_tipo_sangre IN inventario.id_tipo_sangre%TYPE,
    p_delta          IN NUMBER,
    p_id_usuario     IN inventario.id_usuario_actualiza%TYPE
  ) IS
  BEGIN
    UPDATE inventario
       SET unidades_disponibles = NVL(unidades_disponibles,0) + NVL(p_delta,0),
           fecha_actualiza      = SYSDATE,
           id_usuario_actualiza = p_id_usuario
     WHERE id_componente = p_id_componente
       AND id_tipo_sangre = p_id_tipo_sangre;

    IF SQL%ROWCOUNT = 0 THEN
      INSERT INTO inventario(id_componente, id_tipo_sangre, unidades_disponibles, fecha_actualiza, id_usuario_actualiza)
      VALUES(p_id_componente, p_id_tipo_sangre, NVL(p_delta,0), SYSDATE, p_id_usuario);
    END IF;
  END;

  FUNCTION consultar_stock(
    p_id_componente IN inventario.id_componente%TYPE,
    p_id_tipo_sangre IN inventario.id_tipo_sangre%TYPE
  ) RETURN NUMBER IS
    v_stock NUMBER;
  BEGIN
    SELECT unidades_disponibles
      INTO v_stock
      FROM inventario
     WHERE id_componente = p_id_componente
       AND id_tipo_sangre = p_id_tipo_sangre;
    RETURN NVL(v_stock,0);
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RETURN 0;
  END;

  FUNCTION hay_stock(
    p_id_componente IN inventario.id_componente%TYPE,
    p_id_tipo_sangre IN inventario.id_tipo_sangre%TYPE,
    p_necesario      IN NUMBER
  ) RETURN NUMBER IS
  BEGIN
    RETURN CASE WHEN consultar_stock(p_id_componente, p_id_tipo_sangre) >= NVL(p_necesario,0) THEN 1 ELSE 0 END;
  END;
END pkg_inventario;
/

--5  Usuarios

CREATE OR REPLACE PACKAGE pkg_usuario AS
  FUNCTION autenticar(
    p_usuario IN usuario.nombre_usuario%TYPE,
    p_pass    IN usuario.contrasena%TYPE
  ) RETURN NUMBER; -- 1 ok / 0 no

  PROCEDURE cambiar_estado(
    p_id_usuario IN usuario.id_usuario%TYPE,
    p_estado     IN usuario.estado%TYPE
  );

  PROCEDURE crear_usuario(
    p_id_usuario   IN usuario.id_usuario%TYPE,
    p_nombre_usuario IN usuario.nombre_usuario%TYPE,
    p_correo       IN usuario.correo%TYPE,
    p_contrasena   IN usuario.contrasena%TYPE,
    p_estado       IN usuario.estado%TYPE,
    p_id_rol       IN usuario.id_rol%TYPE
  );

  PROCEDURE obtener_usuario(p_id_usuario IN usuario.id_usuario%TYPE, p_out OUT SYS_REFCURSOR);
END pkg_usuario;
/
CREATE OR REPLACE PACKAGE BODY pkg_usuario AS
  FUNCTION autenticar(
    p_usuario IN usuario.nombre_usuario%TYPE,
    p_pass    IN usuario.contrasena%TYPE
  ) RETURN NUMBER IS
    v_cnt NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_cnt
      FROM usuario
     WHERE nombre_usuario = p_usuario
       AND contrasena     = p_pass
       AND estado         = 'Activo';
    RETURN CASE WHEN v_cnt = 1 THEN 1 ELSE 0 END;
  END;

  PROCEDURE cambiar_estado(
    p_id_usuario IN usuario.id_usuario%TYPE,
    p_estado     IN usuario.estado%TYPE
  ) IS
  BEGIN
    UPDATE usuario
       SET estado = p_estado
     WHERE id_usuario = p_id_usuario;
  END;

  PROCEDURE crear_usuario(
    p_id_usuario   IN usuario.id_usuario%TYPE,
    p_nombre_usuario IN usuario.nombre_usuario%TYPE,
    p_correo       IN usuario.correo%TYPE,
    p_contrasena   IN usuario.contrasena%TYPE,
    p_estado       IN usuario.estado%TYPE,
    p_id_rol       IN usuario.id_rol%TYPE
  ) IS
  BEGIN
    INSERT INTO usuario(id_usuario, nombre_usuario, correo, contrasena, estado, id_rol)
    VALUES(p_id_usuario, p_nombre_usuario, p_correo, p_contrasena, p_estado, p_id_rol);
  END;

  PROCEDURE obtener_usuario(p_id_usuario IN usuario.id_usuario%TYPE, p_out OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_out FOR
      SELECT u.*, r.nombre_rol
        FROM usuario u
        LEFT JOIN rol r ON r.id_rol = u.id_rol
       WHERE u.id_usuario = p_id_usuario;
  END;
END pkg_usuario;
/

--6 Bitacora

CREATE OR REPLACE PACKAGE pkg_bitacora AS
  PROCEDURE registrar_accion(
    p_id_usuario IN bitacora.id_usuario%TYPE,
    p_accion     IN bitacora.accion%TYPE,
    p_detalle    IN bitacora.detalle%TYPE
  );
  PROCEDURE listar(p_out OUT SYS_REFCURSOR);
END pkg_bitacora;
/
CREATE OR REPLACE PACKAGE BODY pkg_bitacora AS
  PROCEDURE registrar_accion(
    p_id_usuario IN bitacora.id_usuario%TYPE,
    p_accion     IN bitacora.accion%TYPE,
    p_detalle    IN bitacora.detalle%TYPE
  ) IS
  BEGIN
    INSERT INTO bitacora(id_usuario, accion, detalle)
    VALUES(p_id_usuario, p_accion, p_detalle);
    -- fecha_hora la pone el DEFAULT CURRENT_TIMESTAMP
  END;

  PROCEDURE listar(p_out OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_out FOR
      SELECT b.*, u.nombre_usuario
        FROM bitacora b
        LEFT JOIN usuario u ON u.id_usuario = b.id_usuario
       ORDER BY b.fecha_hora DESC, b.id_bitacora DESC;
  END;
END pkg_bitacora;
/

--7 Componente Sanguineo

CREATE OR REPLACE PACKAGE pkg_componentes AS
  PROCEDURE agregar(
    p_nombre      IN componente_sanguineo.nombre%TYPE,
    p_descripcion IN componente_sanguineo.descripcion%TYPE,
    p_id_out      OUT componente_sanguineo.id_componente%TYPE
  );
  PROCEDURE listar(p_out OUT SYS_REFCURSOR);
  FUNCTION  nombre_por_id(p_id IN componente_sanguineo.id_componente%TYPE) RETURN VARCHAR2;
END pkg_componentes;
/
CREATE OR REPLACE PACKAGE BODY pkg_componentes AS
  PROCEDURE agregar(
    p_nombre      IN componente_sanguineo.nombre%TYPE,
    p_descripcion IN componente_sanguineo.descripcion%TYPE,
    p_id_out      OUT componente_sanguineo.id_componente%TYPE
  ) IS
  BEGIN
    INSERT INTO componente_sanguineo(nombre, descripcion)
    VALUES(p_nombre, p_descripcion)
    RETURNING id_componente INTO p_id_out;
  END;

  PROCEDURE listar(p_out OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_out FOR
      SELECT * FROM componente_sanguineo ORDER BY nombre;
  END;

  FUNCTION nombre_por_id(p_id IN componente_sanguineo.id_componente%TYPE) RETURN VARCHAR2 IS
    v_nombre VARCHAR2(50);
  BEGIN
    SELECT nombre INTO v_nombre
      FROM componente_sanguineo
     WHERE id_componente = p_id;
    RETURN v_nombre;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RETURN NULL;
  END;
END pkg_componentes;
/

--8 Reportes 

CREATE OR REPLACE PACKAGE pkg_reportes AS
  FUNCTION total_donaciones_mes(p_anio IN NUMBER, p_mes IN NUMBER) RETURN NUMBER;
  FUNCTION total_rechazos_mes(p_anio IN NUMBER, p_mes IN NUMBER) RETURN NUMBER;
  PROCEDURE donaciones_detalle_mes(p_anio IN NUMBER, p_mes IN NUMBER, p_out OUT SYS_REFCURSOR);
END pkg_reportes;
/
CREATE OR REPLACE PACKAGE BODY pkg_reportes AS
  FUNCTION total_donaciones_mes(p_anio IN NUMBER, p_mes IN NUMBER) RETURN NUMBER IS
    v_n NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_n
      FROM donacion
     WHERE EXTRACT(YEAR  FROM fecha) = p_anio
       AND EXTRACT(MONTH FROM fecha) = p_mes;
    RETURN v_n;
  END;

  FUNCTION total_rechazos_mes(p_anio IN NUMBER, p_mes IN NUMBER) RETURN NUMBER IS
    v_n NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_n
      FROM rechazo r
      JOIN donacion d ON d.id_donacion = r.id_donacion
     WHERE EXTRACT(YEAR  FROM d.fecha) = p_anio
       AND EXTRACT(MONTH FROM d.fecha) = p_mes;
    RETURN v_n;
  END;

  PROCEDURE donaciones_detalle_mes(p_anio IN NUMBER, p_mes IN NUMBER, p_out OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_out FOR
      SELECT d.id_donacion, d.fecha, d.volumen_ml, d.estado,
             dn.id_donante, dn.nombre, dn.apellido,
             cd.nombre AS centro
        FROM donacion d
        JOIN donante dn       ON dn.id_donante = d.id_donante
        LEFT JOIN centro_donacion cd ON cd.id_centro = d.id_centro
       WHERE EXTRACT(YEAR  FROM d.fecha) = p_anio
         AND EXTRACT(MONTH FROM d.fecha) = p_mes
       ORDER BY d.fecha DESC;
  END;
END pkg_reportes;
/

--9 Estadisticas

CREATE OR REPLACE PACKAGE pkg_estadisticas AS
  FUNCTION total_donantes RETURN NUMBER;
  FUNCTION total_donaciones_periodo(p_ini IN DATE, p_fin IN DATE) RETURN NUMBER;
  FUNCTION porcentaje_rechazo_periodo(p_ini IN DATE, p_fin IN DATE) RETURN NUMBER;
  PROCEDURE top_centros_mes(p_anio IN NUMBER, p_mes IN NUMBER, p_out OUT SYS_REFCURSOR);
END pkg_estadisticas;
/
CREATE OR REPLACE PACKAGE BODY pkg_estadisticas AS
  FUNCTION total_donantes RETURN NUMBER IS
    v_n NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_n FROM donante;
    RETURN v_n;
  END;

  FUNCTION total_donaciones_periodo(p_ini IN DATE, p_fin IN DATE) RETURN NUMBER IS
    v_n NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_n
      FROM donacion
     WHERE fecha >= TRUNC(p_ini)
       AND fecha <  TRUNC(p_fin) + 1;
    RETURN v_n;
  END;

  FUNCTION porcentaje_rechazo_periodo(p_ini IN DATE, p_fin IN DATE) RETURN NUMBER IS
    v_tot NUMBER;
    v_rej NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_tot
      FROM donacion
     WHERE fecha >= TRUNC(p_ini)
       AND fecha <  TRUNC(p_fin) + 1;

    IF NVL(v_tot,0) = 0 THEN
      RETURN 0;
    END IF;

    SELECT COUNT(*) INTO v_rej
      FROM rechazo r
      JOIN donacion d ON d.id_donacion = r.id_donacion
     WHERE d.fecha >= TRUNC(p_ini)
       AND d.fecha <  TRUNC(p_fin) + 1;

    RETURN ROUND(100 * v_rej / v_tot, 2);
  END;

  PROCEDURE top_centros_mes(p_anio IN NUMBER, p_mes IN NUMBER, p_out OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_out FOR
      SELECT cd.id_centro,
             cd.nombre      AS centro,
             COUNT(*)       AS total_donaciones
        FROM donacion d
        JOIN centro_donacion cd ON cd.id_centro = d.id_centro
       WHERE EXTRACT(YEAR  FROM d.fecha) = p_anio
         AND EXTRACT(MONTH FROM d.fecha) = p_mes
       GROUP BY cd.id_centro, cd.nombre
       ORDER BY total_donaciones DESC, cd.nombre;
  END;
END pkg_estadisticas;
/

-- 10 Cnetro Donacon


CREATE OR REPLACE PACKAGE BODY pkg_centro_donacion AS

  PROCEDURE validar_actor(p_actor IN usuario.id_usuario%TYPE) IS
    v NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v FROM usuario WHERE id_usuario = p_actor;
    IF v = 0 THEN
      RAISE_APPLICATION_ERROR(-20090,'Actor (usuario) no existe: '||NVL(p_actor,'(NULL)'));
    END IF;
  END;

  PROCEDURE log_bitacora(p_actor IN usuario.id_usuario%TYPE,
                         p_accion IN VARCHAR2,
                         p_detalle IN VARCHAR2) IS
  BEGIN
    INSERT INTO bitacora(id_usuario, accion, detalle)
    VALUES(p_actor, p_accion, SUBSTR(p_detalle,1,500));
  END;

  PROCEDURE validar_no_duplicado(
    p_id_excluir IN centro_donacion.id_centro%TYPE,
    p_nombre     IN centro_donacion.nombre%TYPE,
    p_ubicacion  IN centro_donacion.ubicacion%TYPE
  ) IS
    v NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v
      FROM centro_donacion
     WHERE UPPER(TRIM(nombre))    = UPPER(TRIM(p_nombre))
       AND UPPER(TRIM(ubicacion)) = UPPER(TRIM(p_ubicacion))
       AND (p_id_excluir IS NULL OR id_centro <> p_id_excluir);
    IF v > 0 THEN
      RAISE_APPLICATION_ERROR(-20091,'Centro duplicado (nombre+ubicaci n).');
    END IF;
  END;

  PROCEDURE validar_existe_centro(p_id IN centro_donacion.id_centro%TYPE) IS
    v NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v FROM centro_donacion WHERE id_centro = p_id;
    IF v = 0 THEN
      RAISE_APPLICATION_ERROR(-20092,'Centro no existe: '||p_id);
    END IF;
  END;

  PROCEDURE registrar_centro_tx(
    p_nombre     IN centro_donacion.nombre%TYPE,
    p_ubicacion  IN centro_donacion.ubicacion%TYPE,
    p_tipo       IN centro_donacion.tipo%TYPE,
    p_actor      IN usuario.id_usuario%TYPE,
    p_id_out     OUT centro_donacion.id_centro%TYPE
  ) IS
  BEGIN
    validar_actor(p_actor);
    validar_no_duplicado(NULL, p_nombre, p_ubicacion);

    INSERT INTO centro_donacion(nombre, ubicacion, tipo)
    VALUES(p_nombre, p_ubicacion, p_tipo)
    RETURNING id_centro INTO p_id_out;

    log_bitacora(p_actor, 'CD_INSERT',
      'Nuevo centro id='||p_id_out||' nombre="'||p_nombre||'" ubicacion="'||p_ubicacion||'" tipo="'||p_tipo||'"');
  END;

  PROCEDURE actualizar_centro_tx(
    p_id_centro  IN centro_donacion.id_centro%TYPE,
    p_nombre     IN centro_donacion.nombre%TYPE,
    p_ubicacion  IN centro_donacion.ubicacion%TYPE,
    p_tipo       IN centro_donacion.tipo%TYPE,
    p_actor      IN usuario.id_usuario%TYPE
  ) IS
  BEGIN
    validar_actor(p_actor);
    validar_existe_centro(p_id_centro);
    validar_no_duplicado(p_id_centro, p_nombre, p_ubicacion);

    UPDATE centro_donacion
       SET nombre    = p_nombre,
           ubicacion = p_ubicacion,
           tipo      = p_tipo
     WHERE id_centro = p_id_centro;

    log_bitacora(p_actor, 'CD_UPDATE',
      'Centro id='||p_id_centro||' -> nombre="'||p_nombre||'", ubicacion="'||p_ubicacion||'", tipo="'||p_tipo||'"');
  END;

  PROCEDURE eliminar_centro_tx(
    p_id_centro  IN centro_donacion.id_centro%TYPE,
    p_actor      IN usuario.id_usuario%TYPE
  ) IS
    v NUMBER;
  BEGIN
    validar_actor(p_actor);
    validar_existe_centro(p_id_centro);

    SELECT COUNT(*) INTO v FROM donacion WHERE id_centro = p_id_centro;
    IF v > 0 THEN
      RAISE_APPLICATION_ERROR(-20093,'No se puede eliminar: hay donaciones asociadas a este centro.');
    END IF;

    DELETE FROM centro_donacion WHERE id_centro = p_id_centro;

    log_bitacora(p_actor, 'CD_DELETE', 'Centro eliminado id='||p_id_centro);
  END;

  PROCEDURE migrar_donaciones_tx(
    p_id_origen  IN centro_donacion.id_centro%TYPE,
    p_id_destino IN centro_donacion.id_centro%TYPE,
    p_actor      IN usuario.id_usuario%TYPE
  ) IS
    v_rows NUMBER := 0;
  BEGIN
    validar_actor(p_actor);
    IF p_id_origen = p_id_destino THEN
      RAISE_APPLICATION_ERROR(-20094,'Centros origen y destino no pueden ser iguales.');
    END IF;
    validar_existe_centro(p_id_origen);
    validar_existe_centro(p_id_destino);

    UPDATE donacion
       SET id_centro = p_id_destino
     WHERE id_centro = p_id_origen;

    v_rows := SQL%ROWCOUNT;

    log_bitacora(p_actor, 'CD_MIGRAR_DONACIONES',
      'De centro '||p_id_origen||' a '||p_id_destino||' - filas afectadas: '||v_rows);
  END;

  PROCEDURE listar(p_out OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_out FOR
      SELECT id_centro, nombre, ubicacion, tipo
        FROM centro_donacion
       ORDER BY nombre;
  END;

  PROCEDURE obtener(p_id_centro IN centro_donacion.id_centro%TYPE, p_out OUT SYS_REFCURSOR) IS
  BEGIN
    OPEN p_out FOR
      SELECT id_centro, nombre, ubicacion, tipo
        FROM centro_donacion
       WHERE id_centro = p_id_centro;
  END;

  PROCEDURE buscar(p_texto IN VARCHAR2, p_out OUT SYS_REFCURSOR) IS
    v_q VARCHAR2(200) := '%'||UPPER(TRIM(p_texto))||'%';
  BEGIN
    OPEN p_out FOR
      SELECT id_centro, nombre, ubicacion, tipo
        FROM centro_donacion
       WHERE UPPER(TRIM(nombre))    LIKE v_q
          OR UPPER(TRIM(ubicacion)) LIKE v_q
          OR UPPER(TRIM(tipo))      LIKE v_q
       ORDER BY nombre;
  END;
END pkg_centro_donacion;
/


-- Cursores

-- 1. Cursor para listar todos los donantes con su tipo de sangre
DECLARE
  CURSOR cur_donantes IS
    SELECT d.id_donante, d.nombre, d.apellido, ts.tipo AS tipo_sangre
    FROM donante d
    LEFT JOIN tipo_sangre ts ON d.id_tipo_sangre = ts.id_tipo_sangre;
BEGIN
  FOR r IN cur_donantes LOOP
    DBMS_OUTPUT.PUT_LINE(r.id_donante || ': ' || r.nombre || ' ' || r.apellido || ' - Tipo sangre: ' || NVL(r.tipo_sangre, 'N/A'));
  END LOOP;
END;
/

-- 2. Cursor para listar donaciones realizadas en un centro espec fico
DECLARE
  CURSOR cur_donaciones_centro(p_id_centro NUMBER) IS
    SELECT id_donacion, id_donante, fecha, volumen_ml, estado
    FROM donacion
    WHERE id_centro = p_id_centro;
BEGIN
  FOR r IN cur_donaciones_centro(1) LOOP
    DBMS_OUTPUT.PUT_LINE('Donacion ' || r.id_donacion || ' de donante ' || r.id_donante || ' volumen: ' || r.volumen_ml || ' ml');
  END LOOP;
END;
/

-- 3. Cursor para listar inventario con nombre del componente y tipo sangre
DECLARE
  CURSOR cur_inventario IS
    SELECT i.id_inventario, c.nombre AS componente, ts.tipo AS tipo_sangre, i.unidades_disponibles
    FROM inventario i
    JOIN componente_sanguineo c ON i.id_componente = c.id_componente
    JOIN tipo_sangre ts ON i.id_tipo_sangre = ts.id_tipo_sangre;
BEGIN
  FOR r IN cur_inventario LOOP
    DBMS_OUTPUT.PUT_LINE('Inventario ID ' || r.id_inventario || ': ' || r.componente || ' - Tipo: ' || r.tipo_sangre || ' - Unidades: ' || r.unidades_disponibles);
  END LOOP;
END;
/

-- 4. Cursor para listar usuarios activos con su rol
DECLARE
  CURSOR cur_usuarios_activos IS
    SELECT u.id_usuario, u.nombre_usuario, r.nombre_rol
    FROM usuario u
    JOIN rol r ON u.id_rol = r.id_rol
    WHERE u.estado = 'Activo';
BEGIN
  FOR r IN cur_usuarios_activos LOOP
    DBMS_OUTPUT.PUT_LINE('Usuario ' || r.nombre_usuario || ' - Rol: ' || r.nombre_rol);
  END LOOP;
END;
/

-- 5. Cursor para listar donaciones rechazadas con la causa
DECLARE
  CURSOR cur_rechazos IS
    SELECT rej.id_rechazo, d.id_donacion, c.descripcion AS causa, rej.observaciones
    FROM rechazo rej
    JOIN donacion d ON rej.id_donacion = d.id_donacion
    JOIN causa_rechazo c ON rej.id_causa = c.id_causa;
BEGIN
  FOR r IN cur_rechazos LOOP
    DBMS_OUTPUT.PUT_LINE('Rechazo ID ' || r.id_rechazo || ': Donacion ' || r.id_donacion || ' - Causa: ' || r.causa || ' - Obs: ' || r.observaciones);
  END LOOP;
END;
/

-- 6. Cursor para listar componentes sangu neos y su descripci n
DECLARE
  CURSOR cur_componentes IS
    SELECT id_componente, nombre, descripcion FROM componente_sanguineo;
BEGIN
  FOR r IN cur_componentes LOOP
    DBMS_OUTPUT.PUT_LINE('Componente ' || r.nombre || ': ' || r.descripcion);
  END LOOP;
END;
/

-- 7. Cursor para listar centros de donaci n por tipo
DECLARE
  CURSOR cur_centros_por_tipo(p_tipo VARCHAR2) IS
    SELECT id_centro, nombre, ubicacion FROM centro_donacion WHERE tipo = p_tipo;
BEGIN
  FOR r IN cur_centros_por_tipo('Hospital') LOOP
    DBMS_OUTPUT.PUT_LINE('Centro ' || r.nombre || ', ubicaci n: ' || r.ubicacion);
  END LOOP;
END;
/

-- 8. Cursor para listar bit cora de acciones de un usuario
DECLARE
  CURSOR cur_bitacora_usuario(p_id_usuario VARCHAR2) IS
    SELECT id_bitacora, accion, fecha_hora, detalle FROM bitacora WHERE id_usuario = p_id_usuario ORDER BY fecha_hora DESC;
BEGIN
  FOR r IN cur_bitacora_usuario('usuario1') LOOP
    DBMS_OUTPUT.PUT_LINE('Acci n: ' || r.accion || ', Fecha: ' || TO_CHAR(r.fecha_hora, 'DD-MM-YYYY HH24:MI:SS') || ', Detalle: ' || r.detalle);
  END LOOP;
END;
/

-- 9. Cursor para listar roles con descripci n
DECLARE
  CURSOR cur_roles IS
    SELECT id_rol, nombre_rol, descripcion FROM rol;
BEGIN
  FOR r IN cur_roles LOOP
    DBMS_OUTPUT.PUT_LINE('Rol ' || r.nombre_rol || ': ' || r.descripcion);
  END LOOP;
END;
/

-- 10. Cursor para listar donaciones por estado
DECLARE
  CURSOR cur_donaciones_estado(p_estado VARCHAR2) IS
    SELECT id_donacion, id_donante, fecha, volumen_ml FROM donacion WHERE estado = p_estado;
BEGIN
  FOR r IN cur_donaciones_estado('Aprobada') LOOP
    DBMS_OUTPUT.PUT_LINE('Donacion ' || r.id_donacion || ' de donante ' || r.id_donante || ', Fecha: ' || TO_CHAR(r.fecha, 'DD-MM-YYYY'));
  END LOOP;
END;
/

-- 11. Cursor para listar causas de rechazo
DECLARE
  CURSOR cur_causas_rechazo IS
    SELECT id_causa, descripcion FROM causa_rechazo;
BEGIN
  FOR r IN cur_causas_rechazo LOOP
    DBMS_OUTPUT.PUT_LINE('Causa ID ' || r.id_causa || ': ' || r.descripcion);
  END LOOP;
END;
/

-- 12. Cursor para listar usuarios por estado y rol
DECLARE
  CURSOR cur_usuarios_estado_rol(p_estado VARCHAR2, p_id_rol NUMBER) IS
    SELECT id_usuario, nombre_usuario, correo FROM usuario WHERE estado = p_estado AND id_rol = p_id_rol;
BEGIN
  FOR r IN cur_usuarios_estado_rol('Activo', 2) LOOP
    DBMS_OUTPUT.PUT_LINE('Usuario ' || r.nombre_usuario || ', correo: ' || r.correo);
  END LOOP;
END;
/

-- 13. Cursor para listar donantes nacidos despu s de una fecha
DECLARE
  CURSOR cur_donantes_fecha(p_fecha DATE) IS
    SELECT id_donante, nombre, apellido, fecha_nacimiento FROM donante WHERE fecha_nacimiento > p_fecha;
BEGIN
  FOR r IN cur_donantes_fecha(TO_DATE('1990-01-01', 'YYYY-MM-DD')) LOOP
    DBMS_OUTPUT.PUT_LINE(r.nombre || ' ' || r.apellido || ', Nacido: ' || TO_CHAR(r.fecha_nacimiento, 'DD-MM-YYYY'));
  END LOOP;
END;
/

-- 14. Cursor para listar donaciones con volumen mayor a un valor
DECLARE
  CURSOR cur_donaciones_volumen(p_min_volumen NUMBER) IS
    SELECT id_donacion, id_donante, volumen_ml FROM donacion WHERE volumen_ml > p_min_volumen;
BEGIN
  FOR r IN cur_donaciones_volumen(450) LOOP
    DBMS_OUTPUT.PUT_LINE('Donacion ' || r.id_donacion || ', Volumen: ' || r.volumen_ml || ' ml');
  END LOOP;
END;
/

-- 15. Cursor para listar donacion_componente con detalles
DECLARE
  CURSOR cur_donacion_componente IS
    SELECT dc.id_donacion_componente, d.id_donacion, c.nombre AS componente, dc.unidades
    FROM donacion_componente dc
    JOIN donacion d ON dc.id_donacion = d.id_donacion
    JOIN componente_sanguineo c ON dc.id_componente = c.id_componente;
BEGIN
  FOR r IN cur_donacion_componente LOOP
    DBMS_OUTPUT.PUT_LINE('Donacion Componente ID ' || r.id_donacion_componente || ': Donacion ' || r.id_donacion || ', Componente ' || r.componente || ', Unidades ' || r.unidades);
  END LOOP;
END;
/


-- Triggers 

-
-- 0) LIMPIEZA de triggers conflictivos/duplicados en DONACION


-- 1) DONACION: validaci n integral (volumen >= 350, fecha no futura, usuario ACTIVO)
CREATE OR REPLACE TRIGGER trg_donacion_check
BEFORE INSERT OR UPDATE ON donacion
FOR EACH ROW
DECLARE
  v_estado_usuario  usuario.estado%TYPE;
BEGIN
  IF :NEW.volumen_ml IS NULL OR :NEW.volumen_ml < 350 THEN
    RAISE_APPLICATION_ERROR(-20001, 'El volumen m nimo permitido es de 350 ml.');
  END IF;

  IF INSERTING OR (UPDATING AND NVL(:NEW.fecha, DATE '1900-01-01') <> NVL(:OLD.fecha, DATE '1900-01-01')) THEN
    IF :NEW.fecha > SYSDATE THEN
      RAISE_APPLICATION_ERROR(-20002, 'La fecha de la donaci n no puede ser futura.');
    END IF;
  END IF;

  SELECT estado INTO v_estado_usuario
    FROM usuario
   WHERE id_usuario = :NEW.id_usuario_registra;

  IF UPPER(v_estado_usuario) <> 'ACTIVO' THEN
    RAISE_APPLICATION_ERROR(-20003, 'El usuario no est  ACTIVO y no puede registrar donaciones.');
  END IF;
END;
/
SHOW ERRORS

-- 2) INVENTARIO: setear fecha en INSERT
CREATE OR REPLACE TRIGGER trg_inv_set_fecha_bi
BEFORE INSERT ON inventario
FOR EACH ROW
BEGIN
  :NEW.fecha_actualiza := NVL(:NEW.fecha_actualiza, SYSDATE);
END;
/
SHOW ERRORS

-- 3) INVENTARIO: setear fecha en UPDATE
CREATE OR REPLACE TRIGGER trg_inv_set_fecha_bu
BEFORE UPDATE ON inventario
FOR EACH ROW
BEGIN
  :NEW.fecha_actualiza := SYSDATE;
END;
/
SHOW ERRORS

-- 4) INVENTARIO: no permitir stock negativo
CREATE OR REPLACE TRIGGER trg_inv_no_negativo
BEFORE INSERT OR UPDATE ON inventario
FOR EACH ROW
BEGIN
  IF NVL(:NEW.unidades_disponibles,0) < 0 THEN
    RAISE_APPLICATION_ERROR(-20004,'Unidades disponibles no puede ser negativo.');
  END IF;
END;
/
SHOW ERRORS

-- 5) DONACION_COMPONENTE: validar unidades > 0
CREATE OR REPLACE TRIGGER trg_dc_valida_unidades
BEFORE INSERT OR UPDATE ON donacion_componente
FOR EACH ROW
BEGIN
  IF NVL(:NEW.unidades,0) <= 0 THEN
    RAISE_APPLICATION_ERROR(-20005,'Las unidades del componente deben ser > 0.');
  END IF;
END;
/
SHOW ERRORS

-- 6) DONACION_COMPONENTE: evitar duplicados (id_donacion,id_componente)
CREATE OR REPLACE TRIGGER trg_dc_unico_par
BEFORE INSERT OR UPDATE ON donacion_componente
FOR EACH ROW
DECLARE
  v NUMBER;
BEGIN
  IF INSERTING THEN
    SELECT COUNT(*)
      INTO v
      FROM donacion_componente
     WHERE id_donacion   = :NEW.id_donacion
       AND id_componente = :NEW.id_componente;
  ELSE  -- UPDATING
    SELECT COUNT(*)
      INTO v
      FROM donacion_componente
     WHERE id_donacion   = :NEW.id_donacion
       AND id_componente = :NEW.id_componente
       AND id_donacion_componente <> :OLD.id_donacion_componente;
  END IF;

  IF v > 0 THEN
    RAISE_APPLICATION_ERROR(-20006, 'Ya existe ese componente para la donaci n.');
  END IF;
END;
/
SHOW ERRORS TRIGGER trg_dc_unico_par


-- 7) DONANTE: normalizaci n + validaci n sexo
CREATE OR REPLACE TRIGGER trg_donante_normaliza
BEFORE INSERT OR UPDATE ON donante
FOR EACH ROW
BEGIN
  :NEW.nombre   := INITCAP(TRIM(:NEW.nombre));
  :NEW.apellido := INITCAP(TRIM(:NEW.apellido));
  :NEW.sexo     := UPPER(TRIM(:NEW.sexo));
  :NEW.correo   := LOWER(TRIM(:NEW.correo));
  IF :NEW.sexo IS NOT NULL AND :NEW.sexo NOT IN ('M','F') THEN
    RAISE_APPLICATION_ERROR(-20007,'Sexo debe ser M o F.');
  END IF;
END;
/
SHOW ERRORS

-- 8) USUARIO: normalizaci n estado/usuario/correo
CREATE OR REPLACE TRIGGER trg_usuario_normaliza
BEFORE INSERT OR UPDATE ON usuario
FOR EACH ROW
BEGIN
  :NEW.estado        := UPPER(TRIM(NVL(:NEW.estado,'ACTIVO')));
  :NEW.nombre_usuario:= LOWER(TRIM(:NEW.nombre_usuario));
  :NEW.correo        := LOWER(TRIM(:NEW.correo));
END;
/
SHOW ERRORS

-- 9) CENTRO_DONACION: normalizaci n de textos
CREATE OR REPLACE TRIGGER trg_centro_normaliza
BEFORE INSERT OR UPDATE ON centro_donacion
FOR EACH ROW
BEGIN
  :NEW.nombre    := INITCAP(TRIM(:NEW.nombre));
  :NEW.ubicacion := INITCAP(TRIM(:NEW.ubicacion));
  :NEW.tipo      := INITCAP(TRIM(:NEW.tipo));
END;
/
SHOW ERRORS

-- 10) RECHAZO: impedir m s de un rechazo por donaci n
CREATE OR REPLACE TRIGGER trg_rechazo_unico
BEFORE INSERT ON rechazo
FOR EACH ROW
DECLARE
  v NUMBER;
BEGIN
  SELECT COUNT(*) INTO v FROM rechazo WHERE id_donacion = :NEW.id_donacion;
  IF v > 0 THEN
    RAISE_APPLICATION_ERROR(-20008,'La donaci n ya tiene un rechazo registrado.');
  END IF;
END;
/
SHOW ERRORS


select *from donante;